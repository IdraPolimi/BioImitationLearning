function obstacleAvoidance_original(traj,obs,r)
%obstacle avoidance with the coupling term formulation
%As described in "Learning coupling terms for obstacle avoidance "

% sample 3D trajectory generated in simulation



traj3d=traj;
%close all
% Dimensions of the problem
ND=3;

% Initializing canonical and transformation system coupling terms
cc=zeros(ND,1);
ct=zeros(ND,1);

% general parameters for DMPs
dt        = 0.001;
tau       = 1;
n_rfs     = [15 15 15];
n=1;
len=1*n*tau/dt;

%Trajectory generated by DMP is going to be stored in Y temporarily and
%finally Y contains the obstacle avoidance trajectories
Y=zeros(floor(len+1),3);

xx=linspace(1,length(traj3d),floor(len+1)+ 3);
x=1:length(traj3d);

% All three original dimensions of the trajectory are in T
T=zeros(floor(len+1),1);

% Parameters for the coupling term - just implementing the first feature
% Ct = gamma*R*v*theta*exp(-beta*theta)*exp(-kd)
gam=1000;
be=3;
ko=2;
% Second coupling term avoiding nearest point
k_r=5;
be_r=100/pi; %%useless 


% Fitting a DMP to each dimension
for i=1:ND
    traj=csaps(x,traj3d(:,i),0.9,xx);
    Y=learn_dcp_batch_orig(i,dt,0,tau,n_rfs(i),0,traj,0,len);
    T(:,i)=Y(:,1);
    dcp('reset_state',i, traj(1));
    dcp('set_goal',i,traj(floor(len+1)),1);
    goal(i)=T(floor(len+1),i);
end

ct=zeros(ND,1);
x1=[];
x2=[];
The=[];
Ct=[];
Op=[];

% Obstacle position and size
%obs= [1.9 1.55 1.75];
%r=[.15 .15 .15];

% Making obstacle avoidance trajectory longer for converging better to goal
len1=3*len;
y=0;
the=0;
ct_r=0;


[sx1 sy1 sz1]=ellipsoid(obs(1,1),obs(1,2),obs(1,3), r(1,1), r(1,2), r(1,3), 50);
[sx2 sy2 sz2]=ellipsoid(obs(2,1),obs(2,2),obs(2,3), r(2,1), r(2,2), r(2,3), 50);
for i=0:len1,
    
    
    for j=1
        obs_old(j,:)=obs(j,:);
        v_obs=(obs(j,:)-obs_old(j,:))./dt;%[0 0 0];
        
        for ID=1:ND
            [y(ID),yd(ID),ydd(ID)]=dcp('run',ID,tau,dt,sum(ct(ID,:),2),cc(ID));%*(1+k_r/abs(op_r(ID)))
            Y(i+1,:,ID)   = [y(ID) yd(ID) ydd(ID)];
            newtraj(i+1,ID)=y(ID);
        end
        
        % angle to the center and nearest point on the surface
        the_p=atan2((-y(2)+obs(j,2)),(-y(1)+obs(j,1)));
        
        phi_p=acos((y(3)-obs(j,3))/(norm(y-obs(j,:))));
        
        % Assuming a ellipsoidal object - finding the point on the surface
        r_p=r(j,1)*r(j,2)*r(j,3)/sqrt((r(j,2)*r(j,3)*cos(the_p)*sin(phi_p))^2+(r(j,1)*r(j,3)*sin(the_p)*sin(phi_p))^2+(r(j,1)*r(j,2)*cos(phi_p))^2);
        
        op=obs(j,:)-[(r_p*cos(the_p)*sin(phi_p)) (r_p*sin(the_p)*sin(phi_p)) (-r_p*cos(phi_p))];
        % Finding the maximum distance
        [m, ind]=max(op);
        r_max=r(j,ind);
        
        op_r=norm(op-y);
        yd=yd-v_obs;
        
        % checking that we are not stationary or at the obstacle center - to
        % keep acos values real
        if(norm(obs(j,:)-y)*norm(yd)~=0 && (sum((obs(j,:)-y).*yd)/(norm(obs(j,:)-y)*norm(yd)))>=-1 && (sum((obs(j,:)-y).*yd)/(norm(obs(j,:)-y)*norm(yd)))<=1)
            the=acos(sum((obs(j,:)-y).*yd)/(norm(obs(j,:)-y)*norm(yd)));
            ct_r=exp(be_r*cos(the));
        end
        % coupling term is R*yd*ct_r where R is a rotation matrix about rot_a
        
        rot_a=cross((obs(j,:)-y),yd);%da + a meno
        Rot_mat=vrrotvec2mat([rot_a pi/2]);
        
        %rot_a = cross(ax, (obs(j,:)-y));
        %Rot_mat=vrrotvec2mat([rot_a pi/2]);
       % Rot_mat_1=vrrotvec2mat([(obs(j,:)-y) pi/2]);
        %Rot_mat=vrrotvec2mat([rot_a pi/2]);
        
        % Adding the two coupling terms together
        ct(:,j)=Rot_mat*yd'*(gam*the*exp(-1*be*the)*exp(-ko*norm(obs(j,:)-y)));%+gam*k_r*the*exp(-1*be*the)*(exp(-5*norm(op_r)/r_max)));%ct 3x1
        
        
    end
    
end

figure,plot3(Y(:,1,1),Y(:,1,2),Y(:,1,3), 'color','r','marker','.');
hold on
axis equal

plot3(T(1:floor(len+1),1),T(1:floor(len+1),2),T(1:floor(len+1),3),'color','b','marker','.')
plot3(goal(1),goal(2),goal(3),'*g');

surf(sx1,sy1,sz1, ones(size(sx1)))
surf(sx2,sy2,sz2, ones(size(sx2)))
legend('changed traj', 'original', 'goal','nearest points','obstacle')


%esegue mov

newnewtraj=[newtraj,zeros(1501,3)];

MOTION=ALMotionProxy('192.168.1.101',9559);
 

timeLists=linspace(1,20,size(newnewtraj,1));

coords_obs = mat2cell(newnewtraj,ones(1501,1),6)

%MOTION.positionInterpolation('LArm',int8(0),coords_obs,int8(7),timeLists,true);